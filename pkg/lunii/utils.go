package lunii

import (
	"archive/zip"
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"math"
	"os"
	"path"
	"path/filepath"
	"time"

	"image"
	_ "image/jpeg"
	_ "image/png"

	"github.com/google/uuid"
	"github.com/olup/lunii-admin/pkg/bmp4"
	"github.com/tosone/minimp3"
	"golang.org/x/image/draw"

	"github.com/jfreymuth/oggvorbis"
	_ "github.com/qiniu/audio/ogg"
	_ "github.com/qiniu/audio/wav"
	"github.com/viert/go-lame"
)

const BLANK_MP3_FILE = "FFFB90C4000000000000000000000000000000000058696E670000000F0000001500000C670030303030393939393943434343434D4D4D4D4D5959595963636363636C6C6C6C6C7676767676808080808C8C8C8C8C9898989898A1A1A1A1A1ADADADADB9B9B9B9B9C3C3C3C3C3CDCDCDCDCDD9D9D9D9E3E3E3E3E3ECECECECECF6F6F6F6F6FFFFFFFF000000504C414D45332E31303004B90000000000000000152024061E410001E000000C671265A6CC000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFBA0C40003C00001FE00000020493B6380000AF9FFFFFFEBA7E8AC7EF7D568E9E3D95C239EE695FFFFFFFFFFFFFFFFFFFFFFFFD3D6D720F16373C928A70D7102A78344C89D9FFAFFEBFFFFFFFFFEBF6676676D88B556B331C81CA43B89746742C862B0CE2C480791DE95000F0FFFFC64FCDFF91B0D4A77CE8D5D48FFFFFFFFFFFFDCDF10F2A4CFF6DE3FD3CB80AA2A0B21881254620E0FFFFD6301A951123577CCB653D653CFFFFFFFFFFFFEEF92C893762B8428166ADE50E2D320A34590902CC314037500090FFFFE7E73B670E7FFD7D57DFFFFFFFFFD752FFF0A3686120BE56443344336E34C7ACB269F791D6DA4BA1212CFFFFF997BDAFCE537D5F32FFFFFFFFFFFDF9EE5F37C663723B113D0FAEB1ACC35BABAE2A7058942000C0B6C7B22EB5A25D7FFFFFFFFFFFFFFFFA529D52849E744BD8CCE8CBD42C7422314A2873032E1220F783121FFFFCAFA9B2A908E8CA5FC80BFAFFFFFFFFEBBF309AB92489E11C60808BA32DAF9D72BB8A3B7DDFCCE3A48A50B67B148C900060FFFFFFFF73E7FA22B2C78DD97FFFFFFFFE472A999CF326651C29B423DDF6159BAAA20D0631315A392071C2331B02B8C07F576AA4B4774A3FFFFFFFFFFFFFFFFFE9D28F4ABF679DDDC416554BEC8A323B34E562B8BA9874615023FFFFCD675CB3FFFFFFFFFFFFFFF9FF7E9C8F3AB650310D4CD084052E93AEB515C7BB7594B1418B2243FFFFCF987E8D39EB2EDF9FFFFFB10C4F1038388011C00000000983A62C4000A79FFFFFFFFFFEFF9EB08FBC74F9FA7FA9976EEEF5CCC6C66BD134817D67955000E0951C92E6A2D5665323D133AEE8F7B687EFFFFFFFFFFDFD776DBAE32D9533AB95912538306EC4391E58B1CE626205808406B7FFFFB10C4F9038569CF1A40047F08B93D2308008FE0FE9F7DA8D3CBA497BBB32B042AADD11D880DD0E71590857126CE033FFFFFC3FAEE5939445CF6DD755FFFFFFFFE5DEBDBCF19D1953B266810D10CC5358186CCD6912312990AE4FFFFE5BD6C93A52BB4446B3864FFFB10C4F58385BDE5164004DF089F3C6304008FE2D35E9FFFFFFFFAFCCE67A316D11854CC9B327F50FD68CB3F927C5776FBB886A9E5295E818C336A033FFFF6EFA7DF5332BE53A5F6AEDFD57FFFFFFE9D726CAF4454523BDDA8B06DA2355B2B9974C8A50AE2E930FFFB20C4F4038575D918400051C8C93CE288009BE1EA7DA6EC79A200E0BD07FFFFE5917CF5EEC18EC827BFFFFFFFFFFFFFAEF836339B848470647CF376A087370AB0401B5394610740E2068A55002E0FFC81A5AC8E438A89DB8E49AFDF3FFFFFFFFFFE5ED665E65886368F303A9B1DE26E383020D4BC1A1D5642A1432B08155B67FFFFFB10C4FB838629E51640047F00A43CA308000A39FF7C3FF2F79E5E3DF9C4CFFFFFFFFFEB9DF722C76B8C4E30B999C8E60C3892915C766EC20AC0AB8B257008A2000F0FFFFFDF2EB9AB0A973E5D5FE7FFFFFFFFFFEFB978A989230CCAE79F0F553BF259827E2186FFFB10C4F7838521E31620047F18AA3C62C8009BE10EA6A2ADC1FFFC8A4D849622F2390C33F992B3F1BF33FFFFFFFFFFEC66E891D18C9A2CCB67162B66F28A8E6215C4B876DB0E21F1C885002B0FFE2D7D99FFECB3433199453323912223AFFFFFFFFFFCE67A5323FFFB10C4F703C685E716400051C86B3C2300000AF982CD0641308F91F6266DF970C7977454277B62ECAD4BF98137B3FFFE74E5AF9B9C065E7304C5610F9EFFFFFFFFF3F61A2EF5B0CD08E13306FFF18F39E5B295B306DACE28D9A42BD0D424CC032FFA37DBA6B657FFFB10C4F903C581E51620047F18CD3D6280009BE2C9E9D3EFFFFFFFFFFDFDDA9B1CCD54D5501564712AA2495550C08C7294E254714C54168222CC25E7383FFFEF003B0E6D1886888F45327ACE8FFFFFFFFFFFF599E50894D9EB320C39D14AB659F6F0AAEB4A36BFFFFB20C4F283C6C5E31220091F08B43CE2C0008FE34112A8DE29CC4919D5033FFFFFD7B9F33C27398B3F5FEBFFFFFFFFCFFE6726C483A95504B276E9DB114D2D0050E28E361AD561AE258E0FFFFEC7466EC98D0502D987CF5A527CB9FFFFFFFFFE7738F79E4163772916B3C6F6DACB9D76769E6265422C952348033298000E0FFFF8FFFB20C4F7038661E71640047F08B6BCE2C4008FE348466C20D1F9B993348B9565CD14FFFFFFFFFFFFDBA3CDC91332416B23D1404C18E6085EF453999BF0998118054739E1FFFFFFFFFFFFD6DA549DAE61473CF9198A3FFFFF637D5819C307A8310228E83E1A28B38B3880885D00002303FFFE619A26411F58463302F4B64EE843E9FFFB10C4FD038555E91A40047F00C83CA2C8008FE14FFFFFFFFFFF9CCACCF9558CC990233FDE079E855096C6DCA613184BC27C0F5F7B97D73DEB2FFFFFFFFFFFFFFFFFFFF14E525AAE644A239AD30AEE099877762CB51000033FFFFFF66AB917E77DF979B6BFFFFFFFFB20C4F80386C5E5164004DF00C7BD2284009BE2FFFFFC34220B648C2CE64CB24712D71486826909A6E0E9E1C61C7561D01E4425BFFFF4BACE775F912F996795D77FFFFFFFFFFF90F47626DC0C1219428E095E24EAB12EA33F068A78A0E0D60900011B03C826FDC8DD4B250DFF6591E8828CFD7ACFFFFFFFFFFFE4FCCD106D1A06FFFB20C4FA838601E516200051D8CD3CA2C8009BE1CC8CCF9F65ED6DDAB38A5FDD05AAE43FDEE7DEA9557543AA2AE935BB569FFFFFFFFFFFEBF92C945A1D4D54443A4EC523E150E625EE821995EB5500001C03A7EDBA2D6D2D51433D190D3D1E9774637FFFFFFFFFFF44E67B22B2D5EF296831794C9446A321CF39D84B38E5027FFFFFFB10C4FF038589E91620047F10CB3CA2C8009BE1FFFFFFFFFFFFFFFFFFFFA8F7113C441A47921160D3C44581AC444C414D45332E313030AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFFFB10C4F9038675E11640047F08A4802348000000AAAAAAAAAAAAAAAAAAAAAAAAAA4C414D45332E313030AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFFFB20C4F4038649DD1860047F0896BCA348008BE1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFFFB10C4FE83C609E91620047F10AF3C22C0008FE3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFFFB10C4FA03C609E11A60047F08A7BAE300000A39AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFFFB10C4F603C629E11A600051C86E806280000000AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFFFB10C4D603C00001FE0000002000003480000004AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"

func logg(datas ...any) {
	for _, data := range datas {
		fmt.Println(data)
	}
	fmt.Println()
}

func boolToShort(boolean bool) int16 {
	if boolean {
		return 1
	} else {
		return 0
	}
}

func ImageReadOrDecode(fileName string, file fs.File) ([]byte, error) {
	content, err := io.ReadAll(file)
	if err != nil {
		fmt.Println("error while reading the file")
		return nil, err
	}

	if path.Ext(fileName) == ".bmp" {
		fmt.Println("bmp detected: " + fileName)
		match := checkByteAtPosition(content, 28, 4)
		if match {
			fmt.Println("bmp4 detected")
			return content, nil
		}
	}

	decoded, err := ImageToBmp4(bytes.NewReader(content))
	if err != nil {
		fmt.Println("Error while decoding the file")
		return nil, err
	}
	return decoded, nil
}

func ImageToBmp4(file io.Reader) ([]byte, error) {
	source, _, err := image.Decode(file)
	if err != nil {
		return nil, err
	}

	// converting image to grayscale
	grayscale := image.NewGray(image.Rect(0, 0, 320, 240))
	draw.NearestNeighbor.Scale(grayscale, grayscale.Bounds(), source, source.Bounds(), draw.Over, nil)

	return bmp4.GetBitmap(grayscale), nil
}

func Mp3ToMp3(fileBytes []byte) ([]byte, error) {
	start := time.Now()

	// maybe mp3 ?
	data, mp3Audio, err := minimp3.DecodeFull(fileBytes)

	fmt.Println("Audio opened in ", time.Since(start))

	if err != nil {
		// if ogg or wav
		// source, _, err := audio.Decode(bytes.NewReader(fileBytes))
		// if err != nil {
		// 	return nil, err
		// }
		// audioBytes, err = ioutil.ReadAll(source)
		// if err != nil {
		// 	return nil, err
		// }
		return nil, errors.New("Could not decode mp3 file - maybe not an MP3 ?")
	}

	return encodeMp3(mp3Audio, data.Channels, data.SampleRate)

}

func encodeMp3(audioBytes []byte, dataChannel int, dataSampleRate int) ([]byte, error) {
	output := new(bytes.Buffer)
	enc := lame.NewEncoder(output)
	defer enc.Close()

	if dataChannel == 1 {
		enc.SetNumChannels(1)
	}

	err := enc.SetVBR(lame.VBROff) //To be in CBR Mode
	if err != nil {
		return nil, err
	}
	enc.SetInSamplerate(dataSampleRate)
	enc.SetQuality(4)
	enc.SetMode(lame.MpegMono)
	enc.SetWriteID3TagAutomatic(false)
	enc.Write(audioBytes)
	enc.Flush()

	return output.Bytes(), nil
}

func float32toint16(num float32) int16 {

	return int16(math.Max(1-(1<<15), (math.Min((1<<15)-1, float64(num)*(1<<16)))))
}

func convertSliceToInt16Slice(mySlice []float32) []byte {
	retval := make([]byte, len(mySlice)*2)
	for i, v := range mySlice {
		binary.LittleEndian.PutUint16(retval[i*2:], uint16(float32toint16(v)))
	}
	return retval
}

func GetByteSlice(r io.Reader) ([]byte, *oggvorbis.Format, error) {
	oggAudio, format, err := oggvorbis.ReadAll(r)
	if err != nil {
		return nil, nil, err
	}
	return convertSliceToInt16Slice(oggAudio), format, nil
}

func OggToMp3(file io.Reader) ([]byte, error) {
	audioBytes, format, err := GetByteSlice(file)
	if err != nil {
		return nil, errors.New("Could not decode ogg file?")
	}

	return encodeMp3(audioBytes, format.Channels, format.SampleRate)
}

func insert(array []uuid.UUID, element uuid.UUID, i int) []uuid.UUID {
	return append(array[:i], append([]uuid.UUID{element}, array[i:]...)...)
}

type DiskStatus struct {
	All   uint64 `json:"all"`
	Used  uint64 `json:"used"`
	Free  uint64 `json:"free"`
	Avail uint64 `json:"avail"`
}

func checkByteAtPosition(bytes []byte, position int, value int) bool {
	// Check if the byte at the given position matches the given value
	if int(bytes[position]) == value {
		return true
	} else {
		return false
	}
}

// This function unzip the given zip file to the given directory
func Unzip(zipFile string, targetDirectory string) error {
	// Open the zip file
	reader, err := zip.OpenReader(zipFile)
	if err != nil {
		return err
	}
	defer reader.Close()

	// Iterate through each file in the zip file
	for _, file := range reader.File {
		// Open the file inside the zip file
		fileReader, err := file.Open()
		if err != nil {
			return err
		}
		defer fileReader.Close()

		// Create the directories
		err = os.MkdirAll(filepath.Join(targetDirectory, path.Dir(file.Name)), 0777)
		if err != nil {
			return err
		}

		// Create the file
		targetFile, err := os.Create(filepath.Join(targetDirectory, file.Name))
		if err != nil {
			return err
		}
		defer targetFile.Close()

		// Copy the file content
		_, err = io.Copy(targetFile, fileReader)
		if err != nil {
			return err
		}
	}

	return nil
}
